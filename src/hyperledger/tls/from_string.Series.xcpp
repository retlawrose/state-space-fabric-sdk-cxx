// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <hpp>
#import hyperledger.tls.from_string.template
#import hyperledger.tls.endpoints.Series
namespace hyperledger::tls {
  //
  // Extract an endpoint series from the syntax.
  // There must be at least one endpoint.
  //
  // series ::= endpoint | endpoint ',' series
  //
  // If any endponit is invalid, then the whole series is invalid.
  //
  template<> inline auto from_string<endpoints::Series>(std::string const &) -> Outcome<endpoints::Series>;
}
#endiv
#divert <ipp>
#import hyperledger.net.error.Code
#import hyperledger.tls.from_string.endpoints.Endpoint
#import std.error_code
#import std.list
namespace hyperledger {
  template<> auto tls::from_string<tls::endpoints::Series>(std::string const &candidate) -> Outcome<endpoints::Series> {
    using Result = Outcome<endpoints::Series>;
    auto const end = candidate.size();
    std::string::size_type pos{0};
    std::list<endpoints::Endpoint> list; // any push_back container will do
    do {
      //
      // host,host,host
      //
      auto const comma = candidate.find(',', pos);
      if (comma == pos) {
        // zero length endpoint syntax
        return Result{std::error_code{net::error::Code::SYNTAX_ENDPOINTS}};
      }
      auto here = from_string<endpoints::Endpoint>(candidate.substr(pos, std::min(comma, end)));
      if (!ok(here)) {
        return Result{error_code(here)};
      }
      list.push_back(value(std::move(here)));
      if (comma >= end) {
        return Result{endpoints::Series{list.begin(), list.end()}};
      }
      pos = 1 + comma;
      if (pos == end) {
        // the syntax ends in a ','
        return Result{std::error_code{net::error::Code::SYNTAX_ENDPOINTS}};
      }
    } while (true);
  }
}
#endiv
