// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <fpp>
namespace hyperledger::tls::endpoints::series {
  //
  // The field-level formatter for the series
  //
  // Usage:
  //
  //   auto series = tls::endpoints::Series{...somehow...};
  //   cerr << format(series, Field::ENDPOINT);
  //   cerr << format(series, Field::HOST);
  //   cerr << format(series, Field::PORT);
  //   cerr << format(series, Field::CA);
  //
  struct Formatter;
}
#endiv
#divert <hpp>
#import hyperledger.required.Character
#import hyperledger.required.Character_Traits
#import hyperledger.string.Storage
#forward hyperledger.tls.endpoints.Series
#import hyperledger.tls.Field
#import std.basic_ostream
namespace hyperledger::tls::endpoints {
  namespace series {
    inline auto format(Series const &, Field = Field::ENDPOINT) -> Formatter;
    inline auto to_string(Formatter const &) -> string::Storage;
    template<required::Character CHAR, required::Character_Traits TRAITS> inline auto operator<<(std::basic_ostream<CHAR, TRAITS> &, Formatter const &) -> std::basic_ostream<CHAR, TRAITS> &;
  }
  struct series::Formatter {
    using Value = Series;
    inline explicit Formatter(Value const &value, Field field) : value{value}, field{field} { }
    Value const &value;
    Field field;
  };
}
#endiv
#divert <ipp>
#import hyperledger.tls.endpoint.Formatter // WATCHOUT - if you don't exhibit this declaration then the format(...) call below fails to have an overload
#import hyperledger.tls.endpoints.Series
#import hyperledger.detail.reformat
#import std.make_ostream_joiner
#import std.transform
namespace hyperledger::tls::endpoints {
  auto series::format(Series const &ss, Field ff) -> Formatter { return Formatter{ss, ff}; }
  auto series::to_string(Formatter const &ff) -> string::Storage { return detail::reformat::to_string(ff); }
  template<required::Character CHAR, required::Character_Traits TRAITS> auto series::operator<<(std::basic_ostream<CHAR, TRAITS> &o, Formatter const &f) -> std::basic_ostream<CHAR, TRAITS> & {
    auto sink = std::make_ostream_joiner(o, ",");
    auto fmt = [&f](auto const &pointwise) { return format(pointwise, f.field); };
    std::transform(f.value.begin(), f.value.end(), sink, fmt);
    return o;
  }
}
#endiv
#divert <cpp>
#import hyperledger.tls.endpoints.series.Series
namespace {
  namespace tests {
    using namespace hyperledger::tls::endpoints::series;
    using hyperledger::tls::endpoints::series::format; // [[FIXTHIS]] remember that namespace ::format occludes ADL for this name; [[REMOVEWHEN]] namespace ::format is subsumed into namespace form::at or such.
    template<typename SERIES> concept Usage = requires(SERIES const &series, std::basic_ostream<char> &outbound) {
      { outbound << format(series) };
    };
    static_assert(Usage<Series>);
  }
}
#endiv
