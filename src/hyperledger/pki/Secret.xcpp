// This is C++2a -*- c++ -*- in the S.C.O.L.D. Stylings that are so popular these days
// Copyright Verizon Media.
// The license statement is in the LICENSE file at the top of the repository; this code is licensable under the Apache 2.0 license.
#divert <fpp>
namespace hyperledger::pki {
  //
  // A secret (a key)
  //
  // Concept:
  //
  //   With all recordation, wrapping and armor.
  //   If you want the unadorned secret material then cast out to the key::Private object
  //
  // Usage:
  //
  //   Creation (1)
  //     auto raw =- openssl::evp::PKey{...somehow...}; ... this is the managed wrapper record of a private+public key
  //     auto sec =- Secret{move(raw)}
  //
  //   Creation (2), alternatively
  //     auto pan = byte::Span{...somehow...};
  //     auto sec = from<Secret>(pan);
  //
  //   Use it
  //     auto str = to_string(sed);
  //     auto key = (key;:Private) sec;
  //
  class Secret;
}
#endiv
#divert <hpp>
#forward hyperledger.crypto.key.Private
#forward hyperledger.crypto.key.Public
#import hyperledger.pki.from.Secret
#import hyperledger.string.Storage
#import openssl.evp.PKey
#import std.byte
#import std.vector
namespace hyperledger {
  namespace pki {
    using std::move;
    using std::swap;
    inline auto swap(Secret &, Secret &) noexcept -> void;
    inline auto to_string(Secret const &) -> string::Storage;
  }
  class pki::Secret {
    using Key = openssl::evp::PKey;
    friend auto from<Secret>(std::vector<std::byte> const &) -> Secret;
    friend auto swap(Secret &, Secret &) noexcept -> void;
    friend auto to_string(Secret const &) -> string::Storage;
    inline explicit Secret(Key);
    using Private = crypto::key::Private;
    using Public = crypto::key::Public;
  public:
    Secret() = default; // needed to allow Secret to be used in Outcome<Secret>
    Secret(Secret const &) = delete; 
    auto operator=(Secret const &) -> Secret & = delete; 
    Secret(Secret &&) = default; 
    auto operator=(Secret &&) -> Secret & = default; 
    operator Private() const;
    operator Public() const;
  private:
    Key key;
  };
}
#endiv
#divert <ipp>
#import hyperledger.crypto.Buffer
#import hyperledger.crypto.key.Private
#import hyperledger.crypto.key.Public
#import openssl.pem.to_string
namespace hyperledger {
  auto pki::swap(Secret &a, Secret &b) noexcept -> void { swap(a.key, b.key); }
  auto pki::to_string(Secret const &s) -> string::Storage { return openssl::pem::to_string(s.key); }
  namespace pki {
    Secret::Secret(Key key) : key{move(key)} { }
  }
}
#divert <cpp>
#import hyperledger.byte.literals
namespace hyperledger::pki {
  // enable when the envelope keypair (evp::PKey) can handle this.
  Secret::operator Private() const {
#define STUB_OUT
#warning STUB_OUT the public and private key conversions
#ifdef STUB_OUT
    using namespace byte::literals;
    auto buf = "preyevitt"_bytespan;
#else
    auto buf = key.private_key<crypto::Buffer>();
#endif
    return Private{move(buf)};
  }
  Secret::operator Public() const {
#ifdef STUB_OUT
    using namespace byte::literals;
    auto buf = "publick"_bytespan;
#else
    auto buf = key.public_key<crypto::Buffer>();
#endif
    return Public{move(buf)};
  }
}
#if 1
#import tests.concepts.hyperledger.pki.Constructible
namespace hyperledger::pki {
  using namespace tests::concepts::hyperledger::pki;
  static_assert(Constructible<Secret>);
}
#else
#import std.is_default_constructible
#import std.is_copy_constructible
#import std.is_move_constructible
#import std.is_copy_assignable
#import std.is_move_assignable
#import nonstd.required.Outcomable
namespace hyperledger::pki {
  static_assert(std::is_default_constructible_v<Secret>);
  static_assert(!std::is_copy_constructible_v<Secret>);
  static_assert(std::is_move_constructible_v<Secret>);
  static_assert(!std::is_copy_assignable_v<Secret>);
  static_assert(std::is_move_assignable_v<Secret>);
  static_assert(nonstd::required::Outcomable<Secret>);
}
#endif
#endiv
