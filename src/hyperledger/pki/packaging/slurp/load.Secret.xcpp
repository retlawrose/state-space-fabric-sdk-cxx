// This is C++2a -*- c++ -*- in the S.C.O.L.D. Stylings that are so popular these days
// Copyright Verizon Media.
// The license statement is in the LICENSE file at the top of the repository; this code is licensable under the Apache 2.0 license.
#divert <hpp>
#import hyperledger.pki.packaging.slurp.load.template
#import hyperledger.pki.Secret
#import openssl.evp.PKey
namespace hyperledger::pki::packaging::slurp {
  //
  // Specialized for pki::Secret
  // which has more ceremony because HyperLedger and OpenSSL differ in how they store secrets (as private+public keys)
  //
  // This continues to be an implementation detail.
  //
  // template<> requires required::openssl::Pairwise<Secret, openssl::evp::PKey> auto load(file::Path const &) -> Secret;
  // template<> requires required::openssl::Pairwise<Secret, openssl::evp::PKey> auto load(Returning, file::Path const &) -> Loaded<Secret>;
  template<> auto load<Secret, openssl::evp::PKey>(file::Path const &) -> Secret;
  template<> auto load<Secret, openssl::evp::PKey>(Returning, file::Path const &) -> Loaded<Secret>;
}
#endiv
#divert <cpp>
#import hyperledger.crypto.key.from
// #import openssl.c.Buffer
#import openssl.ec.Key
#import hyperledger.exception.Unimplemented
namespace hyperledger::pki::packaging {
  template<> auto slurp::load<Secret, openssl::evp::PKey>(Returning, file::Path const &filepath) -> Loaded<Secret> try {
#if 1
#warning WRITETHIS template<> auto slurp::load<Secret, openssl::evp::PKey>(Returning, file::Path const &filepath) -> Loaded<Secret> 
    throw exception::Unimplemented{__FUNCTION__, __FILE__, __LINE__};
#else
    auto loaded = openssl::pem::load<openssl::evp::PKey>(filepath);
    auto got = loaded.get<openssl::ec::Key>(openssl::RETURNING);
    if (got) {
      auto buf = got->buffer();
      return from<Secret>(buf.begin(), buf.end());
    } else {
      return {error::Code::NOT_EC_KEY};
    }
#endif
  } catch (openssl::exception::System const &e) {
    return e.code();
  } catch (openssl::exception::Aspect const &e) {
    return {error::Code{error::Code::DECODE}};
  }
  template<> auto slurp::load<Secret, openssl::evp::PKey>(file::Path const &filepath) -> Secret try {
#if 1
#warning WRITETHIS template<> auto slurp::load<Secret, openssl::evp::PKey>(file::Path const &filepath) -> Secret 
    throw exception::Unimplemented{__FUNCTION__, __FILE__, __LINE__};
#else
    auto buf = openssl::pem::load<openssl::evp::PKey>(filepath).get<openssl::ec::Key>().buffer();
    return from<Secret>(buf.begin(), buf.end());
#endif
#if 1 // [[FIXTHIS]] older module-openssl circa 0.3.0-0.devel threw std::error_code.  AND also openssl::exception::Aspect (descendants).  It wasn't a good idea.
  } catch (std::error_code const &ec) {
    // The caller is responsible for associating the filepath with the failure in some UX setting
    throw exception::System{ec.value(), ec.category(), could_not::READ_THE_FILE};
#endif
#if 0 // #include hyperledger.exception.Filepath
    // [[FIXTHIS]] when module-openssl >= 0.3.0-0.devel starts throwing exceptino::Filepath (a.k.a. sys::filesystem::path), then add that in so that the offending filepath is preserved
  } catch (openssl::exception::Filepath const &theirs) {
    throw exception::Filepath{theirs};
#endif
  } catch (openssl::exception::System const &theirs) {
    // ibidem ("the caller")
    throw exception::System{theirs.code(), could_not::READ_THE_FILE};
  } catch (openssl::exception::Aspect const &e) {
    throw exception::Crypto{"not an Elliptic Curve (EC) Private Key"};
  }
}
#endiv
