// This is C++2a -*- c++ -*- in the S.C.O.L.D. Stylings that are so popular these days
// Copyright Verizon Media.
// The license statement is in the LICENSE file at the top of the repository; this code is licensable under the Apache 2.0 license.
#divert <fpp>
namespace hyperledger::http::error {
  //
  // The (internal) error categories of the Hyperledger PKI (Public Key Infrastructure).
  // these are distinct from the taxonomy of
  // - (external) errors of the HTTP status codes.
  // - operating system errors of system_error or generic_error
  // - C++ runtime errors of future_error, etc.
  //
  class Category;
}
#endiv
#divert <hpp>
#import std.error_category
#import std.error_condition
#import std.string
class hyperledger::http::error::Category : public std::error_category {
  using Ancestor = std::error_category;
  Category() = default;
  friend auto category() -> Category const &;
public:
  auto name() const noexcept -> char const *;
  auto default_error_condition(int code) const noexcept -> std::error_condition;
  auto message(int code) const -> std::string;
};
#endiv
#divert <cpp>
#import hyperledger.http.error.Condition
#import hyperledger.http.error.Code
#import std.to_string
namespace hyperledger::http::error {
  auto Category::name() const noexcept -> char const * { return "hyperledger"; }
  auto Category::default_error_condition(int code) const noexcept -> std::error_condition {
    // Dubious, but we admit both zero (obvious) and 200 (traditional)
    auto condy = 0 == code || 200 == code ? Condition::SUCCESS : Condition::FAILURE;
    return {condy};
  }
  auto Category::message(int codint) const -> std::string {
    switch (code::Enumeration{codint}) {
    case Code::SUCCESS: return "success";
    case Code::FAILURE: return "failure";
      // 100-series
    case Code::CONTINUE: return "continue";
    case Code::SWITCHING_PROTOCOLS: return "switching protocols";
    case Code::PROCESSING: return "processing";
    // 200-series
    case Code::OK: return "ok";
    case Code::CREATED: return "created";
    case Code::ACCEPTED: return "accepted";
    case Code::NON_AUTHORITATIVE: return "non authoritative";
    case Code::NO_CONTENT: return "no content";
    case Code::RESET_CONTENT: return "reset content";
    case Code::PARTIAL_CONTENT: return "partial content";
    case Code::MULTI_STATUS: return "multi status";
    case Code::ALREADY_REPORTED: return "already reported";
    case Code::IM_USED: return "im used";
      // 300-series
    case Code::MULTIPLE_CHOICES: return "multiple choices";
    case Code::MOVED_PERMANENTLY: return "moved permanently";
    case Code::MOVED_TEMPORARILY: return "moved temporarily";
    case Code::SEE_OTHER: return "see other";
    case Code::NOT_MODIFIED: return "not modified";
    case Code::USE_PROXY: return "use proxy";
    case Code::TEMPORARY_REDIRECT: return "temporary redirect";
    case Code::PERMANENT_REDIRECT: return "permanent redirect";
      // 400-series
    case Code::BAD_REQUEST: return "bad request";
    case Code::UNAUTHORIZED: return "unauthorized";
    case Code::PAYMENT_REQUIRED: return "payment required";
    case Code::FORBIDDEN: return "forbidden";
    case Code::NOT_FOUND: return "not found";
    case Code::METHOD_NOT_ALLOWED: return "method not allowed";
    case Code::NOT_ACCEPTABLE: return "not acceptable";
    case Code::PROXY_AUTHENTICATION_REQUIRED: return "proxy authentication required";
    case Code::REQUEST_TIME_OUT: return "request time out";
    case Code::CONFLICT: return "conflict";
    case Code::GONE: return "gone";
    case Code::LENGTH_REQUIRED: return "length required";
    case Code::PRECONDITION_FAILED: return "precondition failed";
    case Code::REQUEST_ENTITY_TOO_LARGE: return "request entity too large";
    case Code::REQUEST_URI_TOO_LARGE: return "request uri too large";
    case Code::UNSUPPORTED_MEDIA_TYPE: return "unsupported media type";
    case Code::RANGE_NOT_SATISFIABLE: return "range not satisfiable";
    case Code::EXPECTATION_FAILED: return "expectation failed";
    case Code::IM_A_TEAPOT: return "im a teapot";
      // 419 unused
      // 420 unused
    case Code::MISDIRECTED_REQUEST: return "misdirected request";
    case Code::UNPROCESSABLE_ENTITY: return "unprocessable entity";
    case Code::LOCKED: return "locked";
    case Code::FAILED_DEPENDENCY: return "failed dependency";
    case Code::TOO_EARLY: return "too early";
    case Code::UPGRADE_REQUIRED: return "upgrade required";
      // 427 unused
    case Code::PRECONDITION_REQUIRED: return "precondition required";
    case Code::TOO_MANY_REQUESTS: return "too many requests";
      // 430 unused
    case Code::REQUEST_HEADER_FIELDS_TOO_LARGE: return "request header fields too large";
    case Code::UNAVAILABLE_FOR_LEGAL_REASONS: return "unavailable for legal reasons";
      // 500-series
    case Code::INTERNAL_SERVER_ERROR: return "internal server error";
    case Code::NOT_IMPLEMENTED: return "not implemented";
    case Code::BAD_GATEWAY: return "bad gateway";
    case Code::SERVICE_UNAVAILABLE: return "service unavailable";
    case Code::GATEWAY_TIME_OUT: return "gateway time out";
    case Code::VERSION_NOT_SUPPORTED: return "version not supported";
    case Code::VARIANT_ALSO_VARIES: return "variant also varies";
    case Code::INSUFFICIENT_STORAGE: return "insufficient storage";
    case Code::LOOP_DETECTED: return "loop detected";
    case Code::NOT_EXTENDED: return "not extended";
    case Code::NETWORK_AUTHENTICATION_REQUIRED: return "network authentication required";
    default:
      return "error #" + std::to_string(codint);
    }
  }
}
#endiv
