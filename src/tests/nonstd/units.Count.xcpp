// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <fpp>
#import nonstd.units.Count // in lieu of nonstd.units
namespace tests::nonstd::units {
  namespace [[eponymous]] count {
    class Count;
    namespace library = ::nonstd::units;
  }
  using count::Count;
}
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
#import nonstd.units.Count
struct tests::nonstd::units::Count : public cppunit::test::Fixture {
  using Subject = library::Count;
  auto test_constructor() -> void;
  auto test_operator_eq() -> void;
  auto test_operator_inc_pre() -> void;
  auto test_operator_inc_post() -> void;
  auto test_operator_inc_fail() -> void;
  auto test_operator_dec_pre() -> void;
  auto test_operator_dec_post() -> void;
  auto test_operator_dec_fail() -> void;
  auto test_to_string() -> void;
  auto test_operator_insert() -> void;
  auto test_scenario_1() -> void;
  auto test_scenario_2() -> void;
  static auto suite() -> cppunit::Test *;
};
#endiv
#divert <cpp>
namespace tests::nonstd::units::count {
  auto Count::test_constructor() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    CPPUNIT_ASSERT(zero != one);
    CPPUNIT_ASSERT(zero == subject);
    CPPUNIT_ASSERT(one != subject);
  }
  auto Count::test_operator_eq() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    CPPUNIT_ASSERT(zero != one);
    CPPUNIT_ASSERT(zero == subject);
  }
  auto Count::test_operator_inc_pre() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    ++subject;
    CPPUNIT_ASSERT(one == subject);
    CPPUNIT_ASSERT(zero != subject);
  }
  auto Count::test_operator_inc_post() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    subject++;
    CPPUNIT_ASSERT(one == subject);
    CPPUNIT_ASSERT(zero != subject);
  }
  auto Count::test_operator_inc_fail() -> void try {
    auto subject = Subject{std::numeric_limits<int unsigned long>::max()};
    ++subject;
    CPPUNIT_ASSERT(false);
  } catch (std::invalid_argument const &) {
    CPPUNIT_ASSERT(true); // the argument ot the increment operator was invalid
  } catch (std::out_of_range const &) {
    CPPUNIT_ASSERT(false); // sure, the result was out of range, but the input to the operator++ function was not
  } catch (std::exception const &) {
    CPPUNIT_ASSERT(false);
  }
  auto Count::test_operator_dec_pre() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{1};
    CPPUNIT_ASSERT(zero != one);
    CPPUNIT_ASSERT(one == subject);
    --subject;
    CPPUNIT_ASSERT(zero == subject);
  }
  auto Count::test_operator_dec_post() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{1};
    CPPUNIT_ASSERT(zero != one);
    CPPUNIT_ASSERT(one == subject);
    subject--;
    CPPUNIT_ASSERT(zero == subject);
  }
  auto Count::test_operator_dec_fail() -> void try {
    auto subject = Subject{std::numeric_limits<int unsigned long>::min()};
    --subject;
    CPPUNIT_ASSERT(false);
  } catch (std::invalid_argument const &) {
    CPPUNIT_ASSERT(true); // the argument ot the increment operator was invalid
  } catch (std::out_of_range const &) {
    CPPUNIT_ASSERT(false); // sure, the result was out of range, but the input to the operator++ function was not
  } catch (std::exception const &) {
    CPPUNIT_ASSERT(false);
  }
  auto Count::test_to_string() -> void {
    auto nnn = Subject{999};
    auto sss = to_string(nnn);
    CPPUNIT_ASSERT_EQUAL("999"s, sss);
  }
  auto Count::test_operator_insert() -> void {
    auto subject = Subject{999};
    std::ostringstream buf;
    std::ostream &outbound{buf};
    auto ok = (bool) (outbound << subject);
    CPPUNIT_ASSERT(ok);
    auto const actual = buf.str();
    auto const expected = "999"s;
    CPPUNIT_ASSERT_EQUAL(expected, actual);
  }
  auto Count::test_scenario_1() -> void {
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    CPPUNIT_ASSERT(zero != one);
    CPPUNIT_ASSERT(zero == subject);
    ++subject;
    CPPUNIT_ASSERT(one == subject);
    --subject;
    CPPUNIT_ASSERT(zero == subject);
    subject++;
    CPPUNIT_ASSERT(one == subject);
    subject--;
    CPPUNIT_ASSERT(zero == subject);
  }
  auto Count::test_scenario_2() -> void {
    using Subject = library::Count;
    auto zero = Subject{0};
    auto one = Subject{1};
    auto subject = Subject{};
    CPPUNIT_ASSERT(zero == subject);
    auto t1 = ++subject;
    CPPUNIT_ASSERT(one == t1);
    CPPUNIT_ASSERT(one == subject);
    auto t2 = --subject;
    CPPUNIT_ASSERT(zero == t2);
    CPPUNIT_ASSERT(zero == subject);
    subject++;
    auto const &t3 = subject;
    CPPUNIT_ASSERT(one == t3);
    CPPUNIT_ASSERT(one == subject);
    subject--;
    auto const &t4 = subject;
    CPPUNIT_ASSERT(zero == t4);
    CPPUNIT_ASSERT(zero == subject);
  }
}
#import rigging.suite.io
auto tests::nonstd::units::Count::suite() -> cppunit::Test * {
  using namespace rigging::suite;
  auto series = Stream{"Count"};
  series << call("constructor", &Count::test_constructor)
         << call("operator==", &Count::test_operator_eq)
         << call("to_string", &Count::test_to_string)
         << call("operator<<", &Count::test_operator_insert)
         << []() {
              auto inc = Stream{"operator++"};
              inc << call("pre", &Count::test_operator_inc_pre)
                  << call("post", &Count::test_operator_inc_post)
                  << call("fail", &Count::test_operator_inc_fail)
                  << END;
              return move(inc);
            }()
         << []() {
              auto dec = Stream{"operator--"};
              dec << call("pre", &Count::test_operator_dec_pre)
                  << call("post", &Count::test_operator_dec_post)
                  << call("fail", &Count::test_operator_dec_fail)
                  << END;
              return move(dec);
            }()
         << []() {
              auto use = Stream{"usage"};
              use << []() {
                       auto sce = Stream{"scenario"};
                       sce << call("1", &Count::test_scenario_1)
                           << call("2", &Count::test_scenario_2)
                           << END;
                       return move(sce);
                     }()
                  << END;
              return move(use);
            }()
         << END;
  return finalize(series);
}
#endiv
