// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <fpp>
#import hyperledger.fabric.southside
#import hyperledger.string
namespace tests::unit::southside {
  namespace [[eponymous]] fixture {
    class Fixture;
    namespace library = ::hyperledger::fabric::southside;
    namespace string = ::hyperledger::string;
  }
  using fixture::Fixture;
}
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
#import hyperledger.string.Storage
struct tests::unit::southside::fixture::Fixture : public cppunit::test::Fixture {
  auto test_ok() -> void;
  auto test_hack_the_spew_case_01() -> void;
  auto test_hack_the_spew_case_02() -> void;
  auto test_hack_the_spew_case_03() -> void;
  static auto suite() -> cppunit::Test *;
private:
  auto contains_only(string::Storage const &candidate, char match) -> bool;
};
#endiv
#divert <ipp>
#import std
namespace tests::unit::southside::fixture {
  using namespace std;
}
#endiv
#divert <cpp>
#import std.all_of
#import hyperledger.fabric.southside.Code
namespace tests::unit::southside::fixture {
  auto Fixture::contains_only(string::Storage const &candidate, char match) -> bool {
    return all_of(candidate.begin(), candidate.end(), [match](char each) { return each == match; });
  }
  auto fixture::Fixture::test_ok() -> void {
    using ::hyperledger::fabric::southside::Code;
    CPPUNIT_ASSERT(!ok(library::Code::FAIL));
    CPPUNIT_ASSERT(ok(library::Code::OK));
  }
}
#import hyperledger.fabric.southside.hack_the_spew
#import std.transform
#import std.back_inserter
#import std.equal
#import std.move
#import std.vector
#import std.byte
#import std.cerr
namespace tests::unit::southside::fixture {
  auto Fixture::test_hack_the_spew_case_01() -> void {
    using namespace ::hyperledger::fabric::southside;
    auto const specimen = (R"spew("ESC[34m1789-03-06 03:31:22.806 UTC [chaincodeCmd] InitCmdFactory -> INFO 001ESC[0m Retrieved channel (CHANNEL) orderer endpoint: orderer.example.com:7050)spew"
                           R"spew(ESC[34m1789-03-06 03:31:22.815 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 002ESC[0m Chaincode invoke successful. result: status:200 payload:"Universal Declaration of the Rights of Man")spew"s);
    auto [c, p] = library::hack_the_spew<vector<byte>>(specimen);
    CPPUNIT_ASSERT(ok(c));
    auto const expected = []() -> vector<byte> {
                                                          auto const specimen = "Universal Declaration of the Rights of Man"s;
                                                          vector<byte> ret;
                                                          transform(specimen.begin(), specimen.end(), back_inserter(ret), [](char c) { return byte(c); });
                                                          return ret;
    }();
    auto const actual = move(p);
    CPPUNIT_ASSERT(equal(expected.begin(), expected.end(), actual.begin(), actual.end()));
  }
  auto Fixture::test_hack_the_spew_case_02() -> void {
    auto const specimen = (R"spew("ESC[34m1789-03-06 03:31:22.806 UTC [chaincodeCmd] InitCmdFactory -> INFO 001ESC[0m Retrieved channel (CHANNEL) orderer endpoint: orderer.example.com:7050)spew"
                           R"spew(ESC[34m1789-03-06 03:31:22.815 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 002ESC[0m Chaincode invoke successful. result: status:000 payload:"Universal Declaration of the Rights of Man")spew"s);
    auto [c, p] = library::hack_the_spew<vector<byte>>(specimen);
    CPPUNIT_ASSERT(!ok(c));
  }
  auto Fixture::test_hack_the_spew_case_03() -> void {
    auto specimen = []() {
                      auto basis = (R"spew("ESC[34m1789-03-06 03:31:22.806 UTC [chaincodeCmd] InitCmdFactory -> INFO 001ESC[0m Retrieved channel (CHANNEL) orderer endpoint: orderer.example.com:7050)spew"
                                    //
                                    // this fails --------------------------------------------------------------------------------------------------------------------------------\\\ (here)
                                    //                                                                                                                                            |||
                                    //                                                                                                                                            vvv
                                    R"spew(ESC[34m1789-03-06 03:31:22.815 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 002ESC[0m Chaincode invoke successful. result: status:000 payload:)spew"s);
                      basis +='"';
                      for (auto i{0}, e{10000}; e != i; ++i) { basis += 'A'; }
                      basis +='"';
                      return basis;
                    }();
    auto [c, p] = library::hack_the_spew<string::Storage>(specimen);
    std::cerr << "DEBUG code=" << (int) c << '\n';
    std::cerr << "DEBUG payload=q(" << p << ")\n";
    CPPUNIT_ASSERT(fail(c));
    CPPUNIT_ASSERT(contains_only(p, 'A'));
  }
}
#import rigging.suite.io
auto tests::unit::southside::fixture::Fixture::suite() -> cppunit::Test * {
  using namespace rigging::suite;
  auto series = Stream{"southside"};
  series << call("ok", &Fixture::test_ok)
         << []() {
              auto hac = Stream{"hack_the_spew"};
              hac << call("01", &Fixture::test_hack_the_spew_case_01)
                  << call("02", &Fixture::test_hack_the_spew_case_02)
                  << call("03", &Fixture::test_hack_the_spew_case_03)
                  << END;
              return move(hac);
            }()
         << END;
  return finalize(series);
}
#endiv
