// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <fpp>
#import std
#import hyperledger.base64
#import hyperledger.byte
namespace tests::unit::base64::decode {
  namespace fixture {
    class Fixture;
    namespace library = ::hyperledger::base64;
    using namespace std;
    namespace byte = ::hyperledger::byte;
  }
  using fixture::Fixture;
}
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
#import hyperledger.string.Storage
#import hyperledger.string.View
struct tests::unit::base64::decode::fixture::Fixture : public cppunit::test::Fixture {
  template<typename CONTAINER> auto test_container() -> void;
  auto test_iterator() -> void;
  auto test_catchable() -> void;
  auto test_failure() -> void;
  static auto suite() -> cppunit::Test *;
protected:
  template<typename CONTAINER> auto validate(string::View expected, CONTAINER const &actual) -> void;
  static string::Storage const PLAINTEXT;
  static string::Storage const CRYPTTEXT;
};
#endiv
#divert <ipp>
namespace tests::unit::base64::decode::fixture {
  using namespace string::literals;
}
#endiv
#divert <tpp>
#import std.lexicographical_compare
#import hyperledger.base64.decode
#import std.cerr
namespace tests::unit::base64::decode::fixture {
  template<typename CONTAINER> auto Fixture::test_container() -> void {
    auto got = library::decode<CONTAINER>(CRYPTTEXT);
    {
      auto &outbound = std::cerr;
      auto printgot = [&outbound](auto const &in) {
                        for (auto ch : in) {
                          outbound << char(ch);
                        }
                        outbound << ")\n";
                      };
      outbound << "DEBUG: gave (crypttext) q(" << CRYPTTEXT << ")\n";
      outbound << "DEBUG: got  (plaintext) q("; printgot(got);
      outbound << "DEBUG: expecting q("; printgot(PLAINTEXT);
    }
    validate(PLAINTEXT, got);
  }
  template<typename CONTAINER> auto Fixture::validate(string::View expected, CONTAINER const &actual) -> void {
    auto compare = [](auto const &left, auto const &right) { return (char)left == (char)right; };
    bool equal = lexicographical_compare(expected.begin(), expected.end(), actual.begin(), actual.end(), compare);
    CPPUNIT_ASSERT(equal);
  }
}
#endiv
#divert <cpp>
#import hyperledger.exception.Aspect
#import hyperledger.byte.Octet
#import std.deque
namespace tests::unit::base64::decode::fixture {
  // echo -n "aGVsbG8gd29ybGQ=" | base64 -d
  // hello world
  string::Storage const Fixture::PLAINTEXT{"hello world"};
  string::Storage const Fixture::CRYPTTEXT{"aGVsbG8gd29ybGQ="};
  auto Fixture::test_iterator() -> void {
    auto got = library::decode<deque<byte::Octet>>(CRYPTTEXT.begin(), CRYPTTEXT.end()); // <------------------------------ test this
    validate(PLAINTEXT, got);
  }
  auto Fixture::test_failure() -> void try {
    library::decode<string::Storage>("NOT BASE 64 AT ALL!!!!!"sv);
    CPPUNIT_ASSERT(false);
  } catch (::hyperledger::exception::Aspect const &) {
    CPPUNIT_ASSERT(true);
  }
}
#import tunitas.base64.Exception
#import tunitas.base64.Code
namespace tests::unit::base64::decode::fixture {
  auto Fixture::test_catchable() -> void try {
    // Show these things are catchable on their own terms.
    // That in turn will give evidence that Fixture::test_failure() can work at all.
    throw tunitas::base64::Code{"not a code"};
  } catch (::tunitas::base64::Exception const &) {
    CPPUNIT_ASSERT(true);
  }
}
#import hyperledger.byte.Octet
#import hyperledger.string.Storage
#import std.deque
#import std.vector
#import std.uint8_t
#import rigging.suite.io
auto tests::unit::base64::decode::fixture::Fixture::suite() -> cppunit::Test * {
  using namespace rigging::suite;
  auto series = Stream{"decode"};
  series << []() {
              auto vec = Stream{"vector"};
              vec << call("byte", &Fixture::test_container<vector<byte::Octet>>)
                  << call("char", &Fixture::test_container<vector<char>>)
                  << call("int8", &Fixture::test_container<vector<int8_t>>)
                  << call("uint8", &Fixture::test_container<vector<int8_t>>)
                  << END;
              return move(vec);
            }()
         << call("deque<byte>", &Fixture::test_container<deque<byte::Octet>>)
         << call("string", &Fixture::test_container<string::Storage>)
         << call("iterator", &Fixture::test_iterator)
         << call("catchable", &Fixture::test_catchable)
         << call("failure", &Fixture::test_failure)
         << END;
  return finalize(series);
}
#endiv
