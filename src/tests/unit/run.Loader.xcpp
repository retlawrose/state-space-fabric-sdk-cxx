// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Verizon Media.
// Licensed under the terms of the Apache-2.0 license.
// See LICENSE file in https://github.com/yahoo/hyperledger-fabric-sdk-c++/blob/master/LICENSE for terms.
#divert <fpp>
#import hyperledger.fabric.v0
namespace tests::unit::run {
  namespace loader {
    namespace library = ::hyperledger::fabric::v0;
    class Loader;
  }
  using loader::Loader;
}
#endiv
#divert <hpp>
#import cppunit.Test
#import cppunit.test.Fixture
#import hyperledger.fabric.v0.run.Arguments
struct tests::unit::run::loader::Loader : public cppunit::test::Fixture {
  using Arguments = library::run::Arguments;
  auto test_fabric() -> void;
  auto test_peer() -> void;
  auto test_chaincode() -> void;
  auto test_orderer() -> void;
  auto test_peers() -> void;
  auto test_client() -> void;
  auto test_call() -> void;
  static auto suite() -> cppunit::Test *;
protected:
  template<typename LOADER> struct Reloader : public LOADER {
    // Make enough of it public for testing
    Reloader() = default;;
    using LOADER::load;
  };
};
#endiv
#divert <cpp>
#import hyperledger.fabric.v0.peer.chaincode.Call // this one is a complete type (the others are fragments)
#import hyperledger.fabric.v0.run.Loader.fabric.Context
#import hyperledger.fabric.v0.Context
auto tests::unit::run::loader::Loader::test_fabric() -> void {
  Reloader<library::run::Loader<library::Context>> subject;
  Arguments args;
  library::peer::chaincode::Call context;
  subject.load(args, context); // <-------------- test this (does it construct?)
}
#import hyperledger.fabric.v0.run.Loader.peer.Context
#import hyperledger.fabric.v0.peer.Context
auto tests::unit::run::loader::Loader::test_peer() -> void {
  Reloader<library::run::Loader<library::peer::Context>> subject;
  Arguments args;
  library::peer::chaincode::Call context;
  subject.load(args, context);
}
#import hyperledger.fabric.v0.run.Loader.chaincode.Context
#import hyperledger.fabric.v0.peer.chaincode.Context
auto tests::unit::run::loader::Loader::test_chaincode() -> void {
  Reloader<library::run::Loader<library::peer::chaincode::Context>> subject;
  Arguments args;
  library::peer::chaincode::Call context;
  subject.load(args, context);
}
#import hyperledger.fabric.v0.run.Loader.Call
auto tests::unit::run::loader::Loader::test_call() -> void {
  Reloader<library::run::Loader<library::peer::chaincode::Call>> subject;
  Arguments args;
  library::peer::chaincode::Call context;
  subject.load(args, context);
}
#import hyperledger.fabric.v0.run.Loader.Orderer
#import hyperledger.fabric.v0.orderer.Contact
auto tests::unit::run::loader::Loader::test_orderer() -> void {
  Reloader<library::run::Loader<library::orderer::Contact>> subject;
  Arguments args;
  library::orderer::Contact contact;
  subject.load(args, contact.endpoint);
}
#import hyperledger.fabric.v0.run.Loader.Peers
#import hyperledger.fabric.v0.peers.Contact
auto tests::unit::run::loader::Loader::test_peers() -> void {
  Reloader<library::run::Loader<library::peers::Contact>> subject;
  Arguments args;
  library::peers::Contact contact;
  subject.load(args, contact.endpoints);
}
#import hyperledger.fabric.v0.run.Loader.Client
#import hyperledger.tls.Client
auto tests::unit::run::loader::Loader::test_client() -> void {
  Reloader<library::run::Loader<::hyperledger::tls::Client>> subject;
  Arguments args;
  ::hyperledger::tls::Client contact;
  subject.load(args, contact);
}
#import rigging.suite.io
auto tests::unit::run::loader::Loader::suite() -> cppunit::Test * {
  using namespace rigging::suite;
  auto series = Stream{"Loader<TYPE>"};
  series << call("fabric", &Loader::test_fabric)
         << call("peer", &Loader::test_peer)
         << call("chaincode", &Loader::test_chaincode)
         << call("call", &Loader::test_call)
         << call("orderer", &Loader::test_orderer)
         << call("peers", &Loader::test_peers)
         << call("client", &Loader::test_client)
         << END;
  return finalize(series);
}
#endiv
